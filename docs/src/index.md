# Introduction
`InteractiveDynamics` is a package that provides applications for interactively exploring dynamical systems. It _extends_ various packages of [JuliaDynamics](https://juliadynamics.github.io/JuliaDynamics/).

!!! info "Example animations"
    All of the animations/videos you will see in this documentation are generated by simply running the scripts of the [`examples`](https://github.com/JuliaDynamics/InteractiveDynamics.jl/tree/master/examples) folder of `InteractiveDynamics`.


Here are some examples of what you can do with `InteractiveDynamics` (see [Index](@ref) below, or the various pages of the side bar for full list of applications)

**Dynamical systems**

```@raw html
<video width="75%" height="auto" controls loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true" type="video/mp4">
</video>
```

**Billiards**

```@raw html
<video width="75%" height="auto" controls loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/bmap.mp4?raw=true" type="video/mp4">
</video>
```

**Agent based models**

```@raw html
<video width="75%" height="auto" controls loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video>
```

## Description

`InteractiveDynamics` is a Julia package that builds on top of the packages of [JuliaDynamics](https://juliadynamics.github.io/JuliaDynamics/) to create interactive applications for dynamical systems of all kinds. It is written exclusively in Julia, taking advantage of the interactive plotting that [GLMakie.jl](http://makie.juliaplots.org/stable/) provides.
`InteractiveDynamics` is great for teaching and demonstrations, but we believe that it can also be taken advantage of in research.

The combination of the following properties make `InteractiveDynamics` a truly unique software (to our knowledge).

* **General purpose**. Arguably the most unique feature of `InteractiveDynamics` is that every application it offers works for _any_ dynamical system (for the class it targets). The first app shown in the introduction works for any discrete system (of any dimensions), the second app works for any 2D billiard of any shape, the third app works for any 2D agent based model (in discrete or continuous space).

* **Fast**. Because internally some of the fastest dynamical systems software and some of the fastest plotting software are used, this makes our applications extremely fast, given the amount of computations and plotted data they handle.

* **Real data.** Everything that is plotted is _real_. For example, the first application shown plots the true orbit diagram (which means that the alpha value is actually the value of the natural density), instead of a pixelated short-hand that allows faster plotting. Since real-data are computed, they are also returned to the user. This means that if the user finds something interesting at any stage of interacting with the application, they can immediately analyze the results in a more thorough and rigorous manner.

* **In real time.**  Most applications of `InteractiveChaso` calculate everything in real-time. This allows true real time interactivity: at any point some model parameter may change and this change will be immediately reflected into the visualizations. Another important consequence of doing calculations in real time is that all applications of `InteractiveDynamics` can evolve dynamical systems potentially forever.

* **Interfacing existing software for dynamical systems**. There is no implementation for what is a "billiard" or a "continuous dynamical system" in `InteractiveDynamics`. Instead, it interfaces software from [JuliaDynamics](https://juliadynamics.github.io/JuliaDynamics/). This means that you can re-use the system that you analyze scientifically and explore it interactively. But most importantly, it means that actually launching the applications typically requires 5-10 new lines of code (since you have may have already written code to e.g. create and analyze a `DynamicalSystem` with DynamicalSystems.jl, you can re-use the identically same instance of that `DynamicalSystem` in e.g. the orbit diagram interactive application).

* **Small source code** The entire source code for e.g. the orbit diagram plot is 200 lines of code, all clear to understand (we hope), allowing one to expand the existing apps, or to make more specialized versions.

## Usage
Using `InteractiveDynamics` is straightforward, and the documentation strings of the exported functions describe in detail their purpose (see the individual pages of the sidebar).

Each application relies on a package of [JuliaDynamics](https://juliadynamics.github.io/JuliaDynamics/), and thus it _requires_ it to run. For example, if you want to use the function [`interactive_orbitdiagram`](@ref), then you must also load `DynamicalSystems` besides `InteractiveDynamics`, e.g.
```julia
using DynamicalSystems, InteractiveDynamics, GLMakie

ds = Systems.some_example_system()

interactive_psos(ds, ...)
```

## Installation

To install do `]add InteractiveDynamics GLMakie`. `GLMakie` is necessary for providing a plotting backend, since `InteractiveDynamics` does not install one by default.

It is expected that you have the latest (stable) versions installed for the library you want to use, e.g. `DynamicalSystems`.

## Index
```@index
Modules = [InteractiveDynamics]
Order   = [:function, :type]
```
